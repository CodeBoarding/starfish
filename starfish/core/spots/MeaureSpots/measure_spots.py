from itertools import product
from typing import Callable, Sequence, Union

import numpy as np
import pandas as pd
import xarray as xr

from starfish.core.imagestack.imagestack import ImageStack
from starfish.core.intensity_table.intensity_table import IntensityTable
from starfish.core.spots.MeaureSpots._base import MeasureSpotsAlgorithmBase
from starfish.core.types import SpotAttributes
from starfish.types import Axes, Features, Number


class MeasureSpotIntensities(MeasureSpotsAlgorithmBase):

    def __init__(self, measurement_function, radius_is_gyration):
        self.measurement_function = measurement_function
        self.radius_is_gyration = radius_is_gyration

    def run(self, spot_locations: SpotAttributes, data_image: ImageStack, *args):
        return MeasureSpotIntensities.measure_spot_intensities(
            data_image=data_image,
            spot_attributes=spot_locations,
            measurement_function=self.measurement_function,
            radius_is_gyration=self.radius_is_gyration,
        )

    @staticmethod
    def measure_spot_intensity(
            image: Union[np.ndarray, xr.DataArray],
            spots: SpotAttributes,
            measurement_function: Callable[[Sequence], Number],
            radius_is_gyration: bool = False,
    ) -> pd.Series:
        """measure the intensity of each spot in spots in the corresponding image

        Parameters
        ----------
        image : Union[np.ndarray, xr.DataArray],
            3-d volume in which to measure intensities
        spots : pd.DataFrame
            SpotAttributes table containing coordinates and radii of spots
        measurement_function : Callable[[Sequence], Number])
            Function to apply over the spot volumes to identify the intensity (e.g. max, mean, ...)
        radius_is_gyration : bool
            if True, indicates that the radius corresponds to radius of gyration, which is a function
            of spot intensity, but typically is a smaller unit than the sigma generated by blob_log.
            In this case, the spot's bounding box is rounded up instead of down when measuring
            intensity. (default False)

        Returns
        -------
        pd.Series :
            Intensities for each spot in SpotAttributes

        """

        def fn(row: pd.Series) -> Number:
            data = image[
                   row['z_min']:row['z_max'],
                   row['y_min']:row['y_max'],
                   row['x_min']:row['x_max']
                   ]
            return measurement_function(data)

        if radius_is_gyration:
            radius = np.ceil(spots.data[Features.SPOT_RADIUS]).astype(int) + 1  # round up
        else:
            radius = spots.data[Features.SPOT_RADIUS].astype(int)  # truncate down to nearest int
        for v, max_size in zip(['z', 'y', 'x'], image.shape):
            # numpy does exclusive max indexing, so need to subtract 1 from min to get centered box
            spots.data[f'{v}_min'] = np.clip(spots.data[v] - (radius - 1), 0, None)
            spots.data[f'{v}_max'] = np.clip(spots.data[v] + radius, None, max_size)
        return spots.data[['z_min', 'z_max', 'y_min', 'y_max', 'x_min', 'x_max']].astype(int).apply(
            fn,
            axis=1
        )

    @staticmethod
    def measure_spot_intensities(
            data_image: ImageStack,
            spot_attributes: SpotAttributes,
            measurement_function: Callable[[Sequence], Number],
            radius_is_gyration: bool = False,
    ) -> IntensityTable:
        """given spots found from a reference image, find those spots across a data_image

        Parameters
        ----------
        data_image : ImageStack
            ImageStack containing multiple volumes for which spots' intensities must be calculated
        spot_attributes : pd.Dataframe
            Locations and radii of spots
        measurement_function : Callable[[Sequence], Number])
            Function to apply over the spot volumes to identify the intensity (e.g. max, mean, ...)
        radius_is_gyration : bool
            if True, indicates that the radius corresponds to radius of gyration, which is
            a function of spot intensity, but typically is a smaller unit than the sigma generated
            by blob_log. In this case, the spot's bounding box is rounded up instead of down when
            measuring intensity. (default False)

        Returns
        -------
        IntensityTable :
            3d tensor of (spot, channel, round) information for each coded spot

        """

        # determine the shape of the intensity table
        ch_labels = data_image.axis_labels(Axes.CH)
        round_labels = data_image.axis_labels(Axes.ROUND)

        # construct the empty intensity table
        intensity_table = IntensityTable.zeros(
            spot_attributes=spot_attributes,
            ch_labels=ch_labels,
            round_labels=round_labels,
        )

        # if no spots were detected, return the empty IntensityTable
        if intensity_table.sizes[Features.AXIS] == 0:
            return intensity_table

        # fill the intensity table
        indices = product(ch_labels, round_labels)
        for c, r in indices:
            image, _ = data_image.get_slice({Axes.CH: c, Axes.ROUND: r})
            blob_intensities: pd.Series = MeasureSpotIntensities.measure_spot_intensity(
                image,
                spot_attributes,
                measurement_function,
                radius_is_gyration=radius_is_gyration
            )
            intensity_table.loc[dict(c=c, r=r)] = blob_intensities

        return intensity_table
